<h1 align="center">
  <br> 
  <img src="https://upload.wikimedia.org/wikipedia/ru/3/39/Java_logo.svg" alt="Технологии Java" width="200"></a>
  <br>
  <br>
  Домашние задания по курсу
  <br>
  <a href="https://www.kgeorgiy.info/courses/java-advanced/index.html">Технологии Java</a>
  <br>
 </h1>
 
 ## 1. [Обход файлов](/walk/src/ru/ifmo/rain/penskaya/walk)
* Разработайте класс Walk, осуществляющий подсчет хеш-сумм файлов.
   - Формат запуска  
     >java Walk <входной файл> <выходной файл>
   - Входной файл содержит список файлов, которые требуется обойти.
   - Выходной файл должен содержать по одной строке для каждого файла. Формат строки:  
     ><шестнадцатеричная хеш-сумма> <путь к файлу>
   - Для подсчета хеш-суммы используйте алгоритм [FNV](https://ru.wikipedia.org/wiki/FNV).
   - Если при чтении файла возникают ошибки, укажите в качестве его хеш-суммы 00000000.
   - Кодировка входного и выходного файлов — UTF-8.
   - Если родительская директория выходного файла не существует, то соответствующий путь надо создать.
   - Размеры файлов могут превышать размер оперативной памяти.
* Усложненная версия:
   - Разработайте класс RecursiveWalk, осуществляющий подсчет хеш-сумм файлов в директориях
   - Входной файл содержит список файлов и директорий, которые требуется обойти. Обход директорий осуществляется рекурсивно.

## 2. [Множество на массиве](/arrayset/ru/ifmo/rain/penskaya/arrayset)
* Разработайте класс ArraySet, реализующие неизменяемое упорядоченное множество.
  - Класс ArraySet должен реализовывать интерфейс SortedSet (упрощенная версия) или NavigableSet (усложненная версия).
  - Все операции над множествами должны производиться с максимально возможной асимптотической эффективностью.
* При выполнении задания следует обратить внимание на:
  - Применение стандартных коллекций.
  - Избавление от повторяющегося кода.
 
## 3. [Студенты](/student/ru/ifmo/rain/penskaya/student)
* Разработайте класс StudentDB, осуществляющий поиск по базе данных студентов.
  - Класс StudentDB должен реализовывать интерфейс StudentQuery (простая версия) или StudentGroupQuery (сложная версия).
  - Каждый метод должен состоять из ровно одного оператора. При этом длинные операторы надо разбивать на несколько строк.
* При выполнении задания следует обратить внимание на:
  - Применение лямбда-выражений и потоков.
  - Избавление от повторяющегося кода.
  
## 4. [Implementor](/implementor/ru/ifmo/rain/penskaya/implementor)
* Реализуйте класс Implementor, который будет генерировать реализации классов и интерфейсов.
  - Аргументы командной строки: полное имя класса/интерфейса, для которого требуется сгенерировать реализацию.
  - В результате работы должен быть сгенерирован java-код класса с суффиксом Impl, расширяющий (реализующий) указанный класс (интерфейс).
  - Сгенерированный класс должен компилироваться без ошибок.
  - Сгенерированный класс не должен быть абстрактным.
  - Методы сгенерированного класса должны игнорировать свои аргументы и возвращать значения по умолчанию.
* В задании выделяются три уровня сложности:
  - Простой — Implementor должен уметь реализовывать только интерфейсы (но не классы). Поддержка generics не требуется.
  - Сложный — Implementor должен уметь реализовывать и классы и интерфейсы. Поддержка generics не требуется.
  
## 7. [Итеративный параллелизм](/parallelism)
* Реализуйте класс IterativeParallelism, который будет обрабатывать списки в несколько потоков.
* В простом варианте должны быть реализованы следующие методы:
  - minimum(threads, list, comparator) — первый минимум;
  - maximum(threads, list, comparator) — первый максимум;
  - all(threads, list, predicate) — проверка, что все элементы списка удовлетворяют предикату;
  - any(threads, list, predicate) — проверка, что существует элемент списка, удовлетворяющий предикату.
* В сложном варианте должны быть дополнительно реализованы следующие методы:
  - filter(threads, list, predicate) — вернуть список, содержащий элементы удовлетворяющие предикату;
  - map(threads, list, function) — вернуть список, содержащий результаты применения функции;
  - join(threads, list) — конкатенация строковых представлений элементов списка.
* Во все функции передается параметр threads — сколько потоков надо использовать при вычислении. Вы можете рассчитывать, что число потоков не велико.
* Не следует рассчитывать на то, что переданные компараторы, предикаты и функции работают быстро.
* При выполнении задания нельзя использовать Concurrency Utilities.
* Рекомендуется подумать, какое отношение к заданию имеют моноиды.
